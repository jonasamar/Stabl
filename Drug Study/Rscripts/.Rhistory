}
# Removing unecessary labels and adding title
plot <- plot +
ggtitle(paste(target_feature, pval, sep=",\np = ")) +
xlab(NULL) +  # Remove x-axis label
ylab(NULL) +  # Remove y-axis label
theme(legend.position = "none") +
theme(plot.title = element_text(size = 6))
return(plot)
}
setwd("/Users/jonasamar/Stabl/Drug Study/Rscripts")
OOL_path <- "/Users/jonasamar/Stabl/Drug Study/Onset of Labor csv"
drug_assay_path <- "/Users/jonasamar/Stabl/Drug Study/Drug assay csv"
library(tidyverse)
library(tidyselect)
library(reshape2)
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(viridis)
library(paletteer)
library(tidyr)
library(janitor)
library(lme4)
library(lmerTest)
library(utils)
library(ggplot2)
library(r2glmm)
library(sjstats)
library(gridExtra)
library(grid)
# Models of interest
final.model <- pseudo_log10.median.linear.model
final.model.type <- "median" #"individual" or "mixed" or "median"
# Chosing features of interest
feature_choice <- "top_feature_index_features"
OOL_features <- top.feature.index
# Chosing thresholds over or under which we consider the effect of the drug as relevant
slope.threshold <- 0
pval.threshold <- 1
drug.ranking <- data.frame(drug = character(),
score = numeric(),
stringsAsFactors = FALSE)
# Getting a normized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
mutate(log.model_index = log10(1 + model_index),
norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
select(feature, norm.log.model_index) %>%
pull(norm.log.model_index) %>%
setNames(pull(feature.index, feature)) %>%
as.list()
# Calculating the score
for (drug in unique(final.model$drug)){
score <- 0
# We sum the scores over all the features for each drug
for (feature in names(OOL_features)){
# Getting the drug effect on the feature
slope <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$slope
pval <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$pval
# Sometimes the values of slope and/or pval is empty so we fill with 0 these values
drug_effect <- ifelse((length(slope)*length(pval) == 0) || (is.na(slope) | is.na(pval)),
0,
drug.effect(slope, pval, slope.threshold, pval.threshold))
# Adding the individual scores of the drug each feature
score <- score - drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]]
}
# Adding the drug and its score to drug.ranking
drug.ranking <- rbind(drug.ranking,
data.frame(drug=drug,
score=score,
stringsAsFactors = FALSE))
}
# Arranging the drugs to see the best drugs on top
drug.ranking <- drug.ranking %>% arrange(desc(score))
drug.ranking
# Models of interest
final.model <- pseudo_log10.median.linear.model
final.model.type <- "median" #"individual" or "mixed" or "median"
# Chosing features of interest
feature_choice <- "top_feature_index_features"
OOL_features <- top.feature.index
# Chosing thresholds over or under which we consider the effect of the drug as relevant
slope.threshold <- 0
pval.threshold <- 1
drug.ranking <- data.frame(drug = character(),
score = numeric(),
stringsAsFactors = FALSE)
# Getting a normized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
mutate(log.model_index = log10(1 + model_index),
norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
select(feature, norm.log.model_index) %>%
pull(norm.log.model_index) %>%
setNames(pull(feature.index, feature)) %>%
as.list()
# Calculating the score
for (drug in unique(final.model$drug)){
score <- 0
# We sum the scores over all the features for each drug
for (feature in names(OOL_features)){
# Getting the drug effect on the feature
slope <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$slope
pval <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$pval
# Sometimes the values of slope and/or pval is empty so we fill with 0 these values
drug_effect <- ifelse((length(slope)*length(pval) == 0) || (is.na(slope) | is.na(pval)),
0,
drug.effect(slope, pval, slope.threshold, pval.threshold))
# Adding the individual scores of the drug each feature
score <- score - drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]]
}
# Adding the drug and its score to drug.ranking
drug.ranking <- rbind(drug.ranking,
data.frame(drug=drug,
score=score,
stringsAsFactors = FALSE))
}
# Arranging the drugs to see the best drugs on top
drug.ranking <- drug.ranking %>% arrange(desc(score))
drug.ranking
drug.ranking <- data.frame(drug = character(),
score = numeric(),
stringsAsFactors = FALSE)
drug.ranking
# Getting a normized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
mutate(log.model_index = log10(1 + model_index),
norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
select(feature, norm.log.model_index) %>%
pull(norm.log.model_index) %>%
setNames(pull(feature.index, feature)) %>%
as.list()
norm.log.feature.index
OOL_features
length(OOL_features)
# Models of interest
final.model <- pseudo_log10.median.linear.model
final.model.type <- "median" #"individual" or "mixed" or "median"
# Chosing features of interest
feature_choice <- "top_feature_index_features"
OOL_features <- top.feature.index
# Chosing thresholds over or under which we consider the effect of the drug as relevant
slope.threshold <- 0
pval.threshold <- 1
View(model.scores)
drug.ranking <- data.frame(drug = character(),
score = numeric(),
stringsAsFactors = FALSE)
# Getting a normized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
mutate(log.model_index = log10(1 + model_index),
norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
select(feature, norm.log.model_index) %>%
pull(norm.log.model_index) %>%
setNames(pull(feature.index, feature)) %>%
as.list()
# Calculating the score
for (drug in unique(final.model$drug)){
score <- 0
# We sum the scores over all the features for each drug
for (feature in names(OOL_features)){
# Getting the drug effect on the feature
print(feature)
slope <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$slope
print(slope)
pval <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$pval
print(pval)
# Sometimes the values of slope and/or pval is empty so we fill with 0 these values
drug_effect <- ifelse((length(slope)*length(pval) == 0) || (is.na(slope) | is.na(pval)),
0,
drug.effect(slope, pval, slope.threshold, pval.threshold))
print(drug_effect)
# Adding the individual scores of the drug each feature
score <- score - drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]]
print(drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]])
}
# Adding the drug and its score to drug.ranking
drug.ranking <- rbind(drug.ranking,
data.frame(drug=drug,
score=score,
stringsAsFactors = FALSE))
}
# Arranging the drugs to see the best drugs on top
drug.ranking <- drug.ranking %>% arrange(desc(score))
drug.ranking
drug.ranking <- data.frame(drug = character(),
score = numeric(),
stringsAsFactors = FALSE)
# Getting a normized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
mutate(log.model_index = log10(1 + model_index),
norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
select(feature, norm.log.model_index) %>%
pull(norm.log.model_index) %>%
setNames(pull(feature.index, feature)) %>%
as.list()
# Calculating the score
for (drug in unique(final.model$drug)){
score <- 0
# We sum the scores over all the features for each drug
for (feature in names(OOL_features)){
# Getting the drug effect on the feature
slope <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$slope
pval <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$pval
# Sometimes the values of slope and/or pval is empty so we fill with 0 these values
drug_effect <- ifelse((length(slope)*length(pval) == 0) || (is.na(slope) | is.na(pval)),
0,
drug.effect(slope, pval, slope.threshold, pval.threshold))
# Adding the individual scores of the drug each feature
score <- score - drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]]
print(score)
}
# Adding the drug and its score to drug.ranking
drug.ranking <- rbind(drug.ranking,
data.frame(drug=drug,
score=score,
stringsAsFactors = FALSE))
}
# Arranging the drugs to see the best drugs on top
drug.ranking <- drug.ranking %>% arrange(desc(score))
drug.ranking
drug.ranking <- data.frame(drug = character(),
score = numeric(),
stringsAsFactors = FALSE)
# Getting a normized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
mutate(log.model_index = log10(1 + model_index),
norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
select(feature, norm.log.model_index) %>%
pull(norm.log.model_index) %>%
setNames(pull(feature.index, feature)) %>%
as.list()
# Calculating the score
for (drug in unique(final.model$drug)){
score <- 0
# We sum the scores over all the features for each drug
for (feature in names(OOL_features)){
# Getting the drug effect on the feature
slope <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$slope
pval <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$pval
# Sometimes the values of slope and/or pval is empty so we fill with 0 these values
drug_effect <- ifelse((length(slope)*length(pval) == 0) || (is.na(slope) | is.na(pval)),
0,
drug.effect(slope, pval, slope.threshold, pval.threshold))
# Adding the individual scores of the drug each feature
score <- score - drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]]
if (is.na(score)){
print("anomaly")
print(OOL_features[[feature]])
print(norm.log.feature.index[[feature]])
}
print("score")
print(score)
}
# Adding the drug and its score to drug.ranking
drug.ranking <- rbind(drug.ranking,
data.frame(drug=drug,
score=score,
stringsAsFactors = FALSE))
}
# Arranging the drugs to see the best drugs on top
drug.ranking <- drug.ranking %>% arrange(desc(score))
drug.ranking
top.feature.index %>% as.data.frame()
top.feature.index %>% as.data.frame() %>% t()
top.feature.index %>% as.data.frame()
top.feature.index %>% t() %>% as.data.frame()
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame()
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame() %>% filter(is.na(V1))
model.info %>% as.data.frame() %>% t() %>% as.data.frame() %>% filter(is.na(V1))
top.feature.index
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame() %>% filter(is.na(V1))
model.info
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame() %>% filter(is.na(V1))
model.info
# Function which returns
# 1 if the model (of the OOL feature) is increasing at TTL
# -1 if the model (of the OOL feature) is decreasing at TTL
# NA if the behavior of the feature is inconclusive (missing model or too weak slope)
# based on the model (contained in a list) itself and its p-value
feature.normal.behavior.at.TTL <- function(model, pval, slope.threshold, pval.threshold, TTL){
if (length(pval) == 0 || is.na(pval) ||pval > pval.threshold || length(model) == 0){
return(0)
}
else{
# Here we focus un the derivative around 0 to estimate the behavior of the feature
model <- model[[1]]
quadratic <- (length(model) == 3)
# Derivative of the model at TTL
# for quadratic model
if (quadratic){
deriv <- 2*model[['DOS2']]*TTL + model[['DOS']]
}
# for linear model
else{
deriv <- model[['DOS']]
}
# Returning effect coefficient
if (abs(deriv) > slope.threshold){
return(deriv/abs(deriv))
}
else{
return(0)
}
}
}
# Function which returns
# 1 if the model (of the OOL feature) is increasing at TTL
# -1 if the model (of the OOL feature) is decreasing at TTL
# 0 if the behavior of the feature is inconclusive (missing model or too weak slope)
# based on the model (contained in a list) itself and its p-value
feature.normal.behavior.at.TTL <- function(model, pval, slope.threshold, pval.threshold, TTL){
if (length(pval) == 0 || is.na(pval) ||pval > pval.threshold || length(model) == 0){
return(0)
}
else{
# Here we focus un the derivative around 0 to estimate the behavior of the feature
model <- model[[1]]
quadratic <- (length(model) == 3)
# Derivative of the model at TTL
# for quadratic model
if (quadratic){
deriv <- 2*model[['DOS2']]*TTL + model[['DOS']]
}
# for linear model
else{
deriv <- model[['DOS']]
}
# Returning effect coefficient
if (abs(deriv) > slope.threshold){
return(deriv/abs(deriv))
}
else{
return(0)
}
}
}
# Top immunome features from the feature.index
# we associate a coeff +1 (increasing) or -1 (decreasing) to the features
# Timepoint of interest
TTL <- -84
# Thresholds to calculate the normal behavior of a given feature
normal.behavior.slope.threshold <- 0.
normal.behavior.pval.threshold <- 10
# Info (model, pval, rmse, ...) of the models at the timepoint TTL
model.info <- merge(df_models, curve.classification, by.x = "feature", by.y = "cytof") %>%
rowwise() %>%
mutate(normal.behavior = feature.normal.behavior.at.TTL(model,
pval,
normal.behavior.slope.threshold,
normal.behavior.pval.threshold,
TTL))
# List of the features and their behavior
top.feature.index <- feature.index %>%
filter(model_index > 0) %>%
left_join(model.info, by="feature") %>%
select(feature, normal.behavior) %>%
pull(normal.behavior) %>%
setNames(pull(feature.index[(feature.index$model_index > 0) & !(is.na(feature.index$model_index)),],
feature)) %>%
as.list()
# Models of interest
final.model <- pseudo_log10.median.linear.model
final.model.type <- "median" #"individual" or "mixed" or "median"
# Chosing features of interest
feature_choice <- "top_feature_index_features"
OOL_features <- top.feature.index
# Chosing thresholds over or under which we consider the effect of the drug as relevant
slope.threshold <- 0
pval.threshold <- 1
drug.ranking <- data.frame(drug = character(),
score = numeric(),
stringsAsFactors = FALSE)
# Getting a normized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
mutate(log.model_index = log10(1 + model_index),
norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
select(feature, norm.log.model_index) %>%
pull(norm.log.model_index) %>%
setNames(pull(feature.index, feature)) %>%
as.list()
# Calculating the score
for (drug in unique(final.model$drug)){
score <- 0
# We sum the scores over all the features for each drug
for (feature in names(OOL_features)){
# Getting the drug effect on the feature
slope <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$slope
pval <- model.scores[(model.scores$feature == feature) & (model.scores$drug == drug),]$pval
# Sometimes the values of slope and/or pval is empty so we fill with 0 these values
drug_effect <- ifelse((length(slope)*length(pval) == 0) || (is.na(slope) | is.na(pval)),
0,
drug.effect(slope, pval, slope.threshold, pval.threshold))
# Adding the individual scores of the drug each feature
score <- score - drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]]
}
# Adding the drug and its score to drug.ranking
drug.ranking <- rbind(drug.ranking,
data.frame(drug=drug,
score=score,
stringsAsFactors = FALSE))
}
# Arranging the drugs to see the best drugs on top
drug.ranking <- drug.ranking %>% arrange(desc(score))
drug.ranking
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame()
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame() %>% filter(is.na(V1))
# Top immunome features from the feature.index
# we associate a coeff +1 (increasing) or -1 (decreasing) to the features
# Timepoint of interest
TTL <- -84
# Thresholds to calculate the normal behavior of a given feature
normal.behavior.slope.threshold <- 0.
normal.behavior.pval.threshold <- 10
# Info (model, pval, rmse, ...) of the models at the timepoint TTL
model.info <- merge(df_models, curve.classification, by.x = "feature", by.y = "cytof") %>%
rowwise() %>%
mutate(normal.behavior = feature.normal.behavior.at.TTL(model,
pval,
normal.behavior.slope.threshold,
normal.behavior.pval.threshold,
TTL))
# List of the features and their behavior
top.feature.index <- feature.index %>%
filter(model_index > 0) %>%
left_join(model.info, by="feature") %>%
select(feature, normal.behavior) %>%
pull(normal.behavior) %>%
setNames(pull(feature.index[(feature.index$model_index > 0) & !(is.na(feature.index$model_index)),],
feature)) %>%
as.list()
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame() %>% filter(is.na(V1))
model.info
top.feature.index %>% as.data.frame() %>% t() %>% as.data.frame() %>% filter(is.na(V1))
model.info
model.info %>% filter(feature=="Bcells_CREB_IFNa")
model.info %>% filter(grepl("Bcells_", feature))
model.info %>% filter(grepl("Bcells_", feature) & grepl("CREB_", feature))
dim(model.index)
dim(df_models)
dim(model_index)
dim(feature.index)
dim(curve.classification)
dim(model.info)
model.info$feature
setdiff(model.info$feature, feature.index$feature)
setdiff(model.info$feature, feature.index$feature)
feature.index$feature
feature.index
setdiff(feature.index$feature, model.info$feature)
OOL_data
""Bcells_CREB_IFNa" %in% colnames(OOL_data)
"Bcells_CREB_IFNa" %in% colnames(OOL_data)
setdiff(df_models$feature, curve.classification$feature)
df_models
df_models %>% filter(grepl("Bcells_CREB"))
df_models %>% filter(grepl("Bcells_CREB", feature))
curve.classification %>% filter(grepl("Bcells_CREB", feature))
curve.classification
curve.classification %>% filter(grepl("Bcells_CREB", cytof))
dim(df_model)
dim(df_models)
setwd("/Users/jonasamar/Stabl/Drug Study/Rscripts")
funct_path <- "/Users/jonasamar/Stabl/Drug Study/Onset of Labor csv/immunome_noEGA_DOS_pen_OOL.csv"
out_path <- "/Users/jonasamar/Stabl/Drug Study/Onset of Labor csv"
library(tidyverse)
library(sjstats)
library(broom)
library(gridExtra)
data <- read.csv(funct_path)
# removing the datapoints that are post partum
data <- data %>% filter(DOS <= 0)
# timepoints
DOS = data$DOS
# timepoints squared
data$DOS2 = DOS^2
# names of the immunome features
cytof <- colnames(data)[3:(length(colnames(data))-1)]
dim(data)
data
data <- read.csv(funct_path)
# removing the datapoints that are post partum
data <- data %>% filter(DOS <= 0)
data
# timepoints
DOS = data$DOS
# timepoints squared
data$DOS2 = DOS^2
# names of the immunome features
cytof <- colnames(data)[3:(length(colnames(data))-1)]
cytof
data <- read.csv(funct_path)
# removing the datapoints that are post partum
data <- data %>% filter(DOS <= 0)
# timepoints
DOS = data$DOS
# timepoints squared
data$DOS2 = DOS^2
data
# names of the immunome features
cytof <- colnames(data)[3:(length(colnames(data))-1)]
data <- read.csv(funct_path)
# removing the datapoints that are post partum
data <- data %>% filter(DOS <= 0)
# timepoints
DOS = data$DOS
# timepoints squared
data$DOS2 = DOS^2
data
# names of the immunome features
cytof <- colnames(data)[2:(length(colnames(data))-1)]
cytof
data
