---
title: "Onset of Labor model training"
output: html_notebook
---

Here we are building a model similar to the one of the OOL study but on the data of the drug assay study. The code is based on the one used for the OOL study. 

## Paths

```{r}
setwd("/Users/jonasamar/Stabl/Drug Study/Rscripts")
OOL_path="/Users/jonasamar/Stabl/Drug Study/Onset of Labor csv"
drug_assay_path="/Users/jonasamar/Stabl/Drug Study/Drug assay csv"
```

## Libraries

```{r}
library(doSNOW)
library(parallel)
library(matrixStats)
library(zoo)
library(ggVennDiagram)
library(tidyverse)
library(readxl)
set.seed(2018)
```

## Importing and preprocessing data

Preprocessing function which:
1 - Remove features with proportion of NA above a certain threshold
2 - Replace remaining NA values with the median of the feature
3 - Remove features with standard deviation below a certain threshold

```{r}
preprocessing <- function(dataset, NA_threshold, std_threshold){
  prepro_data <- dataset
  cols <- colnames(dataset)
  # Removing columns with proportion of missing values above NA_threshold
  rm_cols <- c()
  for (col_name in cols[!cols %in% "ID"]){
    na_count <- sum(is.na(prepro_data[[col_name]]))
    if (na_count/length(prepro_data[[col_name]]) > NA_threshold){
      rm_cols[length(rm_cols)+1] <- col_name
    }
  }
  prepro_data <- prepro_data[,!colnames(prepro_data) %in% rm_cols]
  # Imputing missing values with median of the colum
  for (col_name in cols[!cols %in% "ID"]){
    median <- median(prepro_data[[col_name]], na.rm = TRUE)
    prepro_data[[col_name]][is.na(prepro_data[[col_name]])] <- median
  }
  # Removing columns with standard deviation below std_threshold
  keep_cols <- which(colSds(as.matrix(prepro_data[,-which(names(prepro_data) == "ID")]))>std_threshold)
  prepro_data <- prepro_data[,keep_cols]
  return(prepro_data)
}
```

Importing and preprocessing the data

```{r}
# Outcomes
Yh <- read_csv(paste0(OOL_path, "/outcome_OOL.csv"), show_col_types = FALSE)
# CYTOF data
CYTOF <- read_csv(paste0(OOL_path, "/immunome_noEGA_pen_OOL.csv"), show_col_types = FALSE)
# Reorordering Yh
Yh <- Yh[match(CYTOF$ID, Yh$ID), ][["DOS"]]
# Preprocessing
CYTOF <- preprocessing(CYTOF, 0.2, 0.)
# Patients Id
Id <- as.factor(str_extract(CYTOF[["ID"]], "(?<=P)\\d+"))
```

Backend configuration for paralleled code

```{r}
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)
```

## Model

Helper function for predictive modeling and LOOCV
  Input arguments:
    X: data matrix with patients, and omics measurments on rows and columns, respectively.
    Y: response vector.
    foldid: patients index that is a unique id for all subjects corresponding to the same patient.
    i: the patient id that should be left out during the training process
    parm: parameters of the Lasso 
  Output args,
    ret: a list of predictions on the training and test data with the coefficients of Lasso 

The complete analysis was performed using a similar strategy but using parallel processing to optimize lambda, followed by a stack generalization layer as described in the article.

```{r}
xxx<-function(X, Y, foldid, i, parm)
{
  suppressMessages(library(randomForest, quietly = TRUE))
  suppressMessages(library(glmnet, quietly = TRUE))
  set.seed(2018+123*i)

  X <- X[, -which(colnames(X) == "ID")] # Removing the ID column

  iInd=which(foldid==unique(foldid)[i])
  if(length(iInd)<2){
    iInd=c(iInd, iInd)
  }
  if(parm$scale=='ALL'){
    X=scale(X)
  }
  if(parm$scale=='Patient')
  {
    for(ap in seq(length(unique(foldid))))
    {
      sclidx= which(foldid==unique(foldid)[ap])
      if(length(sclidx)>1)
        X[sclidx]=scale(X[sclidx], scale=F)
    }
    X=scale(X) #creates NA values for 10 features
    na_columns <- which(colSums(is.na(X)) > 0) # Getting the columns that are removed
    X=X[, complete.cases(t(X))] #we remove those features
  }

  XX=X[-iInd,]
  YY=Y[-iInd]
  XT=X[iInd,]
  fld=as.numeric(foldid[-iInd])

  ret = list()
  
  # Removed columns
  ret$rm_cols <- na_columns
  
  # LASSO 1SE
  cvglm = cv.glmnet(XX, YY,  standardize=F, alpha=parm$a, foldid = fld)
  ret$p1 = predict(cvglm, XT, s='lambda.1se')
  ret$ptrain1 = predict(cvglm, XX, s='lambda.1se')
  ret$coef = coef(cvglm, s='lambda.1se')[-1]
  
  # Ridge Regression
  ridge_cv = cv.glmnet(x = XX, y = YY, type.measure = "mse", nfold = 10, alpha = 0)
  ret$ridge_p1 = predict(ridge_cv, XT, s=ridge_cv$lambda.min)
  ret$ridge_ptrain1 = predict(ridge_cv, XX, s=ridge_cv$lambda.min)
  ret$ridge_coef = coef(ridge_cv, s=ridge_cv$lambda.min)[-1]
  
  # Adaptive LASSO
  alasso1_cv = cv.glmnet(x = XX, y = YY, type.measure = "mse", nfold = 10, alpha = parm$a,
                        penalty.factor = 1 / abs(ret$coef),
                        keep = TRUE)
  ret$alasso_p1 = predict(alasso1_cv, XT, s=alasso1_cv$lambda.min)
  ret$alasso_ptrain1 = predict(alasso1_cv, XX, s=alasso1_cv$lambda.min)
  ret$alasso_coef = coef(alasso1_cv, s=alasso1_cv$lambda.min)[-1]

  return(ret)
}
```

Model fitting

```{r}
parm=list()
parm$scale='Patient'
parm$a=1
npt=length(unique(Id))

prdC=foreach(i=seq(npt)) %dopar% xxx(data.matrix(CYTOF), Yh, Id, i, parm)
```

## Evaluation of results

Prediction of the model

```{r}
ccc=vector()
alasso_ccc=vector()
ridge_ccc=vector()
for(i in seq(npt))
{
  iInd=which(Id==unique(Id)[i])
  if(length(iInd)>1)
  {
    ccc[iInd] = prdC[[i]]$p1
    alasso_ccc[iInd] = prdC[[i]]$alasso_p1
    ridge_ccc[iInd] = prdC[[i]]$ridge_p1
  }
  else
  {
    ccc[iInd] = prdC[[i]]$p1[1]
    alasso_ccc[iInd] = prdC[[i]]$alasso_p1[1]
    ridge_ccc[iInd] = prdC[[i]]$ridge_p1[1]
  }
}
```

Performances of the model

```{r}
# LASSO 1SE
require(Metrics)
myPv = cor.test(Yh, ccc, method = 'spearman', exact = FALSE)$p.value
myerr = rmse(ccc, Yh)
myr2 = 1 - sum((Yh - ccc)^2) / sum((Yh - mean(Yh))^2)
mycorr = cor(Yh, ccc, method = "spearman")

data <- data.frame(x = Yh, y = ccc)
ggplot(data, aes(x = x, y = y)) + 
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  labs(x = "DOS", y = "Prediction") +
  ggtitle(paste("Spearmanr : ", round(mycorr, digits = 5), 
                "\nRMSE : ",round(myerr, digits = 5), 
                "\np-value : ",round(myPv, digits = 30), 
                "\nR^2 : ",round(myr2, digits = 5), sep=""))
```

```{r}
# Ridge Regression
require(Metrics)
myPv = cor.test(Yh, ridge_ccc, method = 'spearman', exact = FALSE)$p.value
myerr = rmse(ridge_ccc, Yh)
myr2 = 1 - sum((Yh - ridge_ccc)^2) / sum((Yh - mean(Yh))^2)
mycorr = cor(Yh, ridge_ccc, method = "spearman")

data <- data.frame(x = Yh, y = ridge_ccc)
ggplot(data, aes(x = x, y = y)) + 
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  labs(x = "DOS", y = "Prediction") +
  ggtitle(paste("Spearmanr : ", round(mycorr, digits = 5), 
                "\nRMSE : ",round(myerr, digits = 5), 
                "\np-value : ",round(myPv, digits = 30), 
                "\nR^2 : ",round(myr2, digits = 5), sep=""))
```

```{r}
# Adaptive LASSO
require(Metrics)
myPv = cor.test(Yh, alasso_ccc, method = 'spearman', exact = FALSE)$p.value
myerr = rmse(alasso_ccc, Yh)
myr2 = 1 - sum((Yh - alasso_ccc)^2) / sum((Yh - mean(Yh))^2)
mycorr = cor(Yh, alasso_ccc, method = "spearman")

data <- data.frame(x = Yh, y = alasso_ccc)
ggplot(data, aes(x = x, y = y)) + 
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  labs(x = "DOS", y = "Prediction") +
  ggtitle(paste("Spearmanr : ", round(mycorr, digits = 5), 
                "\nRMSE : ",round(myerr, digits = 5), 
                "\np-value : ",round(myPv, digits = 30), 
                "\nR^2 : ",round(myr2, digits = 5), sep=""))
```

## Model Index

Creation of a vector of the columns that are removed when building the model.

```{r}
rm_cols <- c()
for (iter in seq(prdC)){
  rm_cols <- c(rm_cols, prdC[[iter]]$rm_cols)
}
rm_cols <- unique(rm_cols)
```

Creation the feature index with adaptive lasso.

```{r}
feature.index <- data.frame(feature = character(),
                            pval = double(),
                            mean_abs_coef = double(),
                            model_index = double(),
                            stringsAsFactors = FALSE)
cols <- colnames(CYTOF[,-c(1, rm_cols)])

for (i in seq(1, length(cols))){
  # Name of the feature
  feature <- cols[i]
  # P value based on a spearman test
  pval <- cor.test(Yh, CYTOF[[feature]], method = 'spearman', exact = FALSE)$p.value
  # Collecting all the absolute values of the coefficients of the AdaLASSO
  coefs <- c()
  for (iter in seq(prdC)){
    coefs[iter] <- abs(prdC[[iter]]$alasso_coef[i])
  }
  # Mean of the coefficients
  mean_abs_coef <- mean(coefs)
  # Adding the feature to feature.index
  feature.index <- rbind(feature.index,
                         data.frame(feature=feature,
                                    pval=pval,
                                    mean_abs_coef=mean_abs_coef,
                                    model_index=-abs(mean_abs_coef)*log10(pval),
                                    stringsAsFactors = FALSE))
}
feature.index <- feature.index %>% arrange(desc(model_index))
```
Saving feature.index

```{r}
save(feature.index, file=paste0(OOL_path, "/feature_index.rda"))
```

## Overlap with OOL paper

```{r}
# List of features
x <- list(OOL_paper = c("CD56loCD16posNK_STAT1_IFNa",
                        #"Granulocytes",
                        "CD4Tnaive_MAPKAPK2_IFNa",
                        "ncMCs_CREB_GMCSF",
                        "CD8Tem_MAPKAPK2_unstim",
                        "pDCs_STAT1_IFNa",
                        "Bcells_MAPKAPK2_LPS",
                        "CD4Tem_MAPKAPK2_unstim",
                        "CD8Tem_MAPKAPK2_IFNa",
                        #"Bcells",
                        "CD4Tem_NFkB_IL246",
                        "CD4Tcm_IkB_unstim",
                        #"mDCs_STAT6_IFNa",
                        "pDCs_STAT6_IFNa",
                        #"mDCs_MAPKAPK2_unstim", 
                        "pDCs_MAPKAPK2_unstim"), 
          Top_model_index = feature.index %>%
                                filter(model_index > 0.2) %>%
                                select(feature) %>%
                                unlist() %>%
                                as.character())

ggVennDiagram(x, label_alpha = 0)
```


